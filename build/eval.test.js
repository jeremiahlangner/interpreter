"use strict";import l from"node:test";import t from"assert";import r from"./eval";let a=new r;l("Lexer should fail to generate tokens for invalid syntax",async e=>{await e.test("An unrecognized token should log an error and return no value.",()=>{t.strictEqual(a.eval(";"),void 0),t.strictEqual(a.eval("!"),void 0),t.strictEqual(a.eval("|"),void 0)})}),l("Evaluator should evaluate string, boolean, number, and list literals.",async e=>{await e.test('The string "42" should evaluate to the number 42.',()=>{t.strictEqual(a.eval("42"),42)}),await e.test('The string "true" should evaluate to a true boolean value.',()=>{t.strictEqual(a.eval("true"),!0)}),await e.test('The string "false" should evaluate to the number false boolean value.',()=>{t.strictEqual(a.eval("false"),!1)}),await e.test('The string "this is a string" should evaluate to the string literal "this is a string".',()=>{t.strictEqual(a.eval('"this is a string"'),"this is a string")}),await e.test("The string 'this is a string' should evaluate to the string literal 'this is a string'.",()=>{t.strictEqual(a.eval("'this is a string'"),"this is a string")}),await e.test('The string "[1, "string", true]" should evaluate to the list literal [1, "string", true].',()=>{const s=a.eval('[1, "string", true]');t.strictEqual(Array.isArray(s),!0),t.strictEqual(s.length,3),t.strictEqual(s[0],1),t.strictEqual(s[1],"string"),t.strictEqual(s[2],!0)})}),l("Evaluator should evaluate number expressions using arithmetic operators to number literals.",async e=>{await e.test("1 + 1 should equal 2.",()=>{t.strictEqual(a.eval("1 + 1"),2)}),await e.test("1 - 1 should equal 0.",()=>{t.strictEqual(a.eval("1 - 1"),0)}),await e.test("1 * 1 should equal 1.",()=>{t.strictEqual(a.eval("1 * 1"),1)}),await e.test("1 / 1 should equal 1.",()=>{t.strictEqual(a.eval("1 / 1"),1)}),await e.test("-1 / 1 should equal -1.",()=>{t.strictEqual(a.eval("-1 / 1"),-1)})}),l("Evaluator should evaluate logical operators properly within simple logical expressions.",async e=>{await e.test("Simple boolean expressions using and should evaluate to their logical boolean values.",()=>{t.strictEqual(a.eval("true and true"),!0),t.strictEqual(a.eval("false and false"),!1),t.strictEqual(a.eval("not false and true"),!0),t.strictEqual(a.eval("false and not true"),!1),t.strictEqual(a.eval("not true and not true"),!1),t.strictEqual(a.eval("not false and not false"),!0)}),await e.test("Simple boolean expressions using or should evaluate to their logical boolean values.",()=>{t.strictEqual(a.eval("true or true"),!0),t.strictEqual(a.eval("false or false"),!1),t.strictEqual(a.eval("not false or true"),!0),t.strictEqual(a.eval("false or not true"),!1),t.strictEqual(a.eval("not true or not true"),!1),t.strictEqual(a.eval("not false or not false"),!0)})}),l("Evaluator should evaluate comparisons to boolean values.",async e=>{await e.test('Simple equality expressions using "=" should return a boolean',()=>{t.strictEqual(a.eval("4 = 4"),!0),t.strictEqual(a.eval("4 = 5"),!1)}),await e.test('Simple inequality expressions using "not" should return an expected boolean',()=>{t.strictEqual(a.eval("not (4 = 4)"),!1),t.strictEqual(a.eval("not (4 = 5)"),!0)}),await e.test('Simple equality expressions using ">" and "<" should return a boolean',()=>{t.strictEqual(a.eval("4 > 4"),!1),t.strictEqual(a.eval("5 > 4"),!0),t.strictEqual(a.eval("4 < 4"),!1),t.strictEqual(a.eval("4 < 5"),!0),t.strictEqual(a.eval("4 > 5"),!1),t.strictEqual(a.eval("4 >= 5"),!1),t.strictEqual(a.eval("4 <= 4"),!0),t.strictEqual(a.eval("4 <= 5"),!0),t.strictEqual(a.eval("5 >= 5"),!0),t.strictEqual(a.eval("5 >= 4"),!0)})}),l("Evaluator should evaluate parenthetical expressions correctly.",async e=>{await e.test("Evaluator should evaluate literals contained in parentheses.",()=>{t.strictEqual(a.eval("(4)"),4),t.strictEqual(a.eval('("string")'),"string"),t.strictEqual(a.eval("('string')"),"string"),t.strictEqual(a.eval("(true)"),!0),t.strictEqual(a.eval("(false)"),!1),t.strictEqual(a.eval("([1])")[0],1),t.strictEqual(a.eval("(1,2,3,4)")[0],1)}),await e.test("Evaluator should evaluate parenthetical expressions before operators of lower precedence.",()=>{t.strictEqual(a.eval("(4 * 5) + 1"),21),t.strictEqual(a.eval("(4 + 5) * 2"),18)}),await e.test("Evaluator should evaluate nested parenthetical expressions.",()=>{t.strictEqual(a.eval("((4 * 5) - 1) + 1"),20)})}),l("Evaluator should evaluate date strings as numbers.",async e=>{await e.test("Evaluator should evaluate dates from apparent date strings",()=>{t.strictEqual((a.eval('date("3/3/1988")')/1e9).toFixed(),(new Date("3/3/1988").valueOf()/1e9).toFixed()),t.strictEqual((a.eval('date("March 3, 1988")')/1e9).toFixed(),(new Date("March 3, 1988").valueOf()/1e9).toFixed())}),await e.test("Evaluator should evaluate pre-specified relative dates",()=>{t.strictEqual((a.eval('date("now")')/1e9).toFixed(),(new Date().valueOf()/1e9).toFixed())})}),l("Evaluator should find objects using comparative expressions",async e=>{await e.test("Evaluator should find values that match conditions and return true.",()=>{a.data={obj:[{foo:"bar",baz:"lur"},{foo:"bar"},{foo:"d"}]},t.strictEqual(a.eval("find(obj, true)"),!0),t.strictEqual(a.eval('find(obj, foo = "bar")'),!0),t.strictEqual(a.eval('find(obj, foo = "bar" and baz = "lur")'),!0),t.strictEqual(a.eval('find(obj, (foo = "bar") and (baz = "test"))'),!1),a.data={obj:["foo","bar","baz"]},t.strictEqual(a.eval('find(obj, $ = "foo")'),!0),t.strictEqual(a.eval('find(obj, $ = "baz")'),!0),t.strictEqual(a.eval('find(obj, $ = "not a value")'),!1),a.data={foo:"bar",bar:"baz",baz:!0},t.strictEqual(a.eval("find($, $ = true)"),!0),t.strictEqual(a.eval('find($, $ = "bar")'),!0),t.strictEqual(a.eval('find($, $ = "baz")'),!0),t.strictEqual(a.eval("find($, $ = false)"),!1)}),await e.test("Evalutator should return false for too few arguments for find.",()=>{t.strictEqual(a.eval("find()"),!1),t.strictEqual(a.eval("find($ = true)"),!1)})}),l("Evaluator should parse and evaluate assigned data, identifier, and index expressions.",async e=>{await e.test("Evaluator should evaluate data from path identifiers.",()=>{let s=new r({test1:1,test2:"string",test3:[1,!0,["test"]],test4:{test5:0}});t.strictEqual(s.eval("test1"),1),t.strictEqual(s.eval("test2"),"string"),t.strictEqual(s.eval("test3[1]"),!0),t.strictEqual(s.eval("test3[2][0]"),"test"),t.strictEqual(s.eval('test4["test5"]'),0),t.strictEqual(s.eval("test4.test6"),void 0),s.data={five:{a:[1,2,3,{b:"foo"},{b:"bar"}]}},t.strictEqual(s.eval('five["a"][?]["b"] = "foo"'),!0),t.strictEqual(s.eval('five["a"][?]["b"] = "bar"'),!0),t.strictEqual(s.eval('five["a"][?]["b"] = "baz"'),!1)}),await e.test("Evaluator should parse JSON strings to data.",()=>{let s=new r('{ "test1": "test" }');t.strictEqual(s.eval("test1"),"test"),s=new r("bad json"),t.strictEqual(s.eval("test1"),void 0)})}),l("Evaluator should evaluate and reference rules assigned in a ruleset.",async e=>{await e.test("Evaluator should parse JSON string rules.",()=>{const s=new r({test:"data"},`{"test": "true", "test1": "(4 + 5) >= 9", "test2": ":test + 'string'"}`);t.strictEqual(s.eval(":test"),!0),t.strictEqual(s.eval(":test1"),!0),t.strictEqual(s.eval(":test2"),"truestring")})});
