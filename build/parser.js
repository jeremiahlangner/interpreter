"use strict";const e={none:0,lowest:1,conjoin:2,compare:3,sum:4,product:5,exponent:6,prefix:7,postfix:8,index:9},n={"=":e.compare,"!=":e.compare,"<":e.compare,">":e.compare,"<=":e.compare,">=":e.compare,in:e.conjoin,and:e.conjoin,or:e.conjoin,"+":e.sum,"-":e.sum,"/":e.product,"*":e.product,"^":e.exponent,"[":e.index};class o{constructor(r){this.lexer=r}parsePrefixExpression(){switch(this.current.type){case"ident":case"string":case"question":case"root":return{token:this.current,value:this.current.literal};case"number":return{token:this.current,value:Number(this.current.literal)};case"boolean":return{token:this.current,value:this.current.literal==="true"};case"lparen":case"lbracket":const r=this.current,t=[],s=r.type==="lparen"?"rparen":"rbracket";for(;this.peek.type!==s;){const i=this.parse(e.lowest);this.peek.type=="comma"&&this.next(),t.push(i)}return this.next(),{token:r,value:t};default:return{token:this.current,operator:this.current.literal,right:this.parse(e.prefix)}}}parseInfixExpression(r){switch(this.current.type){case"lbracket":const t=this.current,s=this.parse(e.lowest);return this.peek.type==="rbracket"&&this.next(),{token:t,left:r,index:s};default:return{token:this.current,left:r,operator:this.current.literal,right:this.parse(n[this.current.literal])}}}next(r){if(r&&this.peek.type!=r.type)throw new Error(`Syntax error at position ${this.lexer.position+1} - Expected '${r.literal}' and found '${this.peek.literal}'`);this.current=this.peek,this.peek=this.lexer.next()}peekPrecedence(){return this.peek&&n[this.peek.literal]||0}parse(r=0){if(this.next(),r||this.next(),!this.current)return;if(!this.current.prefix)throw new Error(`Could not parse expression at position ${this.lexer.position}, '${this.current.literal}' is not a valid prefix`);let t=this.parsePrefixExpression();for(;this.peek&&r<this.peekPrecedence();){if(!this.peek.infix)return t;this.next(),t=this.parseInfixExpression(t)}return t}}export{o as Parser};
