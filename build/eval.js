"use strict";import{Parser as x}from"./parser";import h from"./lexer";function u(a){try{return JSON.parse(a)}catch(e){console.log("Failed to parse data.",e)}return{}}export default class f{constructor(e={},r={}){this._rules={};this.lexer=new h,this.parser=new x(this.lexer),this.data=typeof e=="string"?u(e):e,this.rules=typeof r=="string"?u(r):r}eval(e){return this.lexer.lex(e),this.evaluate(this.parser.parse())}getDataByPath(e){if(!e)return;const r=e.split(".");if(!r.length)return;let i=this.data;for(const n of r){if(typeof i>"u")return;i=i[n]}return i}evaluate(e){if(!e)return;switch(e.token.type){case"boolean":case"string":case"number":case"question":return e.value;case"ident":return this.getDataByPath(e.token.literal);case"root":return this.data;case"lparen":case"lbracket":let t=[];if(e.value)return t=e.value.map(s=>this.evaluate(s)),e.token.type==="lparen"&&t.length<=1?t[0]:t}if(!e.left){if(e.operator==="not")return!this.evaluate(e.right);if(e.operator==="-")return-this.evaluate(e.right);if(e.operator==="date"){let t=this.evaluate(e.right);return typeof t=="string"&&(t==="today"&&(t=new Date().toLocaleDateString()),t==="now"&&(t=new Date().toString())),new Date(t).valueOf()}if(e.operator==="find"){if(!e.right.value[1])return console.log('Expression error. Expected 2 arguments for function "find".',e),!1;const t=this.evaluate(e.right.value[0]),s=new f;for(const o in t)if(s.data=t[o],s.evaluate(e.right.value[1]))return!0;return!1}if(e.operator===":"){let t;return this._rules[e.right.value]&&(t=this._rules[e.right.value]),this.rules[e.right.value]?(t||(this.lexer.lex(this.rules[e.right.value]),this._rules[e.right.value]=this.parser.parse(),t=this._rules[e.right.value]),this.evaluate(t)):e.right.value}}if(e.index){const t=this.evaluate(e.left),s=this.evaluate(e.index);if(t?._indices||s==="?"){const o=t._indices?[...t._indices,s]:[s];return{data:t.data||t,_indices:o}}return t?t[s]:void 0}let r=this.evaluate(e.left),i=this.evaluate(e.right);const n=e.operator;return r&&r._indices&&(r=l(r)),i&&i._indices&&(i=l(i)),{"+":r+i,"-":r-i,"*":r*i,"/":r/i,">":r>i,"<":r<i,">=":r>=i,"<=":r<=i,"=":Array.isArray(r)?r.includes(i):r===i,in:i&&i.includes?i.includes(r):!1,and:r&&i,or:r||i}[n]}}function l(a){let e=a.data,r=0,i=a._indices[r];for(;i&&i!=="?"&&e;)r++,e=e[i],i=a._indices[r];if(i==="?"){let n=[];for(const t in e){const s=l({data:e[t],_indices:a._indices.slice(r+1)});s&&n.push(s)}n.length>0&&(e=n)}return e}
